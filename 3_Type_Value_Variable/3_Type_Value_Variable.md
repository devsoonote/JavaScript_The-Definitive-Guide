# 3. 타입, 값, 변수

> 자바스크립트 완벽가이드를 읽고 작성한 개인 노트입니다. 조원들과 토론을 통해서 서로 배운 내용과 깨달은 내용에 대해서 논의한 부분 또한 함께 녹이려고 노력했습니다.
>
1. **타입이란?**
    - 프로그래밍 언어에서 표현하고 조작할 수 있는 값의 종류를 타입이라 부르며, 어떤 타입을 지원하는지가 프로그래밍 언어의 가장 기본적인 특징을 이룬다.

2. **자바스크립트 타입**
    - 자바스크립트 타입은 기본 타입과 객체 타입 둘로 나뉘는데, 자바스크립트 기본 타입에는 숫자, 문자열, 불(boolean), null, undefined, 심벌(Symbol) 타입이 있다.
    - 자바스크립트에서 숫자, 문자열, 불, 심벌, null, undefined 중 어느 것에도 속하지 않는 값은 모두 객체이다. (객체, 배열, Set[값의 집합], Map[키와 값의 연결], RegExp[텍스트 패턴], Date타입, Error타입...)

    - **숫자[Number]: 기본 타입**
        - 정수와 함께 실수를 대략적으로 표현
        - 자바스크립트는 IEEE 754 표준에서 정의하는 64비트 부동 소수점 형식을 사용해 숫자를 표현한다.
        - -2^53(-9,007,199,254,740,992) ~ 2^53(9,007,199,254,740,992) 범위의 정수를 정확히 표현할 수 있다. → 이보다 큰 정수 값을 사용하면 정확도가 떨어질 수 있다.
        - 배열 인덱싱이나 비트 연산자 등 일부 자바스크립트 연산은 32비트 정수를 사용한다. (왜달라?)
        - 숫자 리터럴: 자바스크립트 프로그램에 직접 기입한 숫자로 정수로 기입하면 정수 리터럴이고, 실수로 작성하면 부동 소수점 리터럴이다.
        - 숫자리터럴 안에 밑줄을 써서 리터럴을 읽기 쉽게 나눠 쓸 수 있다.

            ```jsx
            let billion = 1_000_000_000; // 천 단위 구분자로 사용
            let bytes = 0x89_AB_CD_EF; // 바이트 구분자로 사용
            let bites = 0b0001_1101_0111; // 4비트 구분자로 사용 
            let fraction = 0.123_456_789; // 소수점 아래 부분에도 사용 가능
            ```

            - 정수 리터럴
                - 10진 정수 리터럴 뿐만 아니라 16진수 값도 인식한다. → 16진수 리터럴은 0x 또는 0X로 시작하며 그 뒤에 숫자를 작성한다. `ex) 0xff ⇒ 255 (15*16 + 15), 0xBADCAFE ⇒ 195939070`
                - ES6 이후로는 2진수 및 8진수 정수도 표현할 수 있게 되었다. → 2진수는 0b(0B)을 앞에 붙이고, 8진수는 0o(0O)을 앞에 붙여 정수를 표현할 수 있다. `ex) 0b10101 ⇒ 21, 0o377 ⇒ 255`

            - 부동 소수점 리터럴
                - 부동 소수점 리터럴에는 소수점이 포함될 수 있다. 즉, 실수의 전통적 문법을 사용한다
                - 부동 소수점 리터럴은 지수 표기법으로도 표현할 수 있다 → 실수 다음에 e(E)를 쓰고, 그 뒤에 선택 사항인 플러스 또는 마이너스 기호, 마지막으로 지수를 나타내는 정수를 쓰는 형식 `[digits][.digits][(E|e)[(+|-)]digits]` `ex. 6.02e23 ⇒ 6.02 * 10^23`

        - 자바스크립트 산술 연산
            - 자바스크립트는 산술 연산자(`+`(더하기),`-`(빼기),`*`(곱하기),`/`(나누기),`%`(나머지),`**`(지수))를 통해 숫자를 조작한다
            - 산술 연산 과정에 0으로 나누거나 오버플로, 언더플로가 발생해도 에러를 일으키지 않는다.
                - 오버플로: 계산 결과가 자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우  (`Infinity` or `-Infinity`를 반환한다)
                - 언더플로: 계산 결과가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까운 경우 (`0` or `음의 0`을 반환한다)

            - 무한한 값에 다른 숫자를 더하거나, 빼거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값이다. → 부호는 바뀔 수 있다.
            - 자바스크립트를 0으로 나눠도 에러가 일어나지 않는다 → 무한대 또는 음의 무한대를 반환할 뿐이다
            - `NaN`로 반환되는 상황
                1. 0을 0으로 나누는 경우: `NaN(Not a Number)`를 반환한다 → 0을 0으로 나누는 경우는 정의되어 있지 않음
                2. 무한대를 무한대로 나누는 경우 / 무한대에 0을 곱하는 경우
                3. 음수의 제곱근을 구하려는 경우
                4. 숫자로 변환할 수도 없는 피연산자에 산술 연산자를 적용하려 하는 경우

        - `NaN`(Not  a Number)
            - 자기 자신을 포함해 어떤 값과도 같지 않다 (`x = NaN; x === NaN; false;`) ⇒ `Number.isNaN(x)` 사용해서 판별가능
            - 전역 함수 `isNaN()`은 `Number.isNaN()`과 비슷하다
                - 이 함수는 인자가 `NaN`이거나 숫자가 아니면서 숫자로 변환할 수도 없는 값일 때 `true`를 반환한다.

        - 이진 부동 소수점 숫자와 반올림 오류
            - 실수는 무한이 많지만, 자바스크립트의 부동 소수점 형식으로 정확히 표현할 수 있는 숫자는 유한하다. → 자바스크립트로 실수를 다룰 때 실제 숫자의 근삿값으로 표현될 때가 자주 있다.
            - **IEEE 754 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024 같은 분수는 정확히 표현할 수 있으나 10진수인 1/10, 1/100 같은 숫자는 정확히 표현할 수 없다. 이진 부동 소수점은 0.1 같은 단순한 숫자를 정확히 표현하지 못한다**
            - Tip: 부동 소숫점 근사값 때문에 프로그램에 문제가 생긴다면 정수로 변환하는 것을 고려해보기. 예를 들어 돈을 계산할 때 0.1달러 대신 10센트로 계산하는 방식을 사용

        - **BigInt: ES2020에서 정의한 자바스크립트의 최신 기능 중 하나이다**
            - 지원 브라우저: 크롬, 파이어폭스, 엣지, 노드, 사파리(14버전~)
            - 값이 정수인 숫자 타입
            - 다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가된 타입이다
            - **타이밍 공격을 방지할 수 없으므로 암호화에는 사용할 수 없다**
                - 타이밍 공격이란?
                - 왜 BigInt는 타이밍 공격을 방지할 수 없을까?
            - `BigInit 리터럴`:  연속된 숫자 다음에 소문자 n을 붙인 형식, 기본적으로 10진수지만 0b, 0o, 0x를 앞에 붙여 이진, 8진, 16진수의 BigInt를 만들 수 있다
            - `BigInt()`: 자바스크립트 숫자, 문자열을 BigInt 타입으로 변환
            - 자바스크립트 숫자와 산술 연산 비슷 / 나눗셈을 할 때 나머지를 버린다는 점이 다르다
            - BigInt형 연산은 BigInt형 값을 리턴한다
            - BigInt형 값과 일반 숫자를 섞어서 사용 불가능 (비교 연산자는 가능)
                - 왜 섞어서 사용이 불가능할까?

                    <aside>
                    💡 A와 B, 숫자 타입이 있다고 정의하였을 때, A 숫자 타입이 B 숫자 타입보다 더 광범위하다면, 두 가지의 타입이 섞였을 때, A 숫자 타입의 값을 반환하도록 정의한다면 섞어서 사용이 가능하다. 

                  그러나 BigInt 타입은 단지 정수만 표현할 수 있고, 자바스크립트 숫자는 실수까지 표현할 수 있기 때문에 바라보는 측면에 따라 광범위한 정의가 달라질 수 있다. 그렇기 때문에 섞어서 사용이 불가능하다.

                    </aside>

                - 섞어서 사용해야하는 상황이라면, `BigInt()` or `Number()`를 사용해 명시적으로 형 변형하기

                    ```jsx
                       let bigint = 1n;
                       let number = 2;
                    
                       // 숫자를 bigInt로 
                       alert(bigint + BigInt(number)); // 3
                    
                       // bigint를 숫자로 
                       alert(Number(bigint) + number); // 3
                    ```
                
            - 자바스크립트 숫자 Infinity를 BigInt로 변경하면 왜 에러가 날까?
                
                ```jsx
                   const n = 900719925474099111111111111111212121212121212121312412321321321312312312312312312392104823048328585094138509423850948350984390584309584310958431905809431859014859041385901485490185904138590185908132490328490381290483290483219048312904832190489320148903248080890340324032143029482319048903218490328409321840232
                   console.log(n); // Infinity
                   console.log(BigInt(n)); // VM744:1 Uncaught RangeError: The number Infinity cannot be converted to a BigInt because it is not an integer
                ```
                
                - VM744:1 Uncaught RangeError: The number Infinity cannot be converted to a BigInt because it is not an integer
                - 
        
    - **문자열[String]: 기본 타입**
        - 16비트(2byte) 값이 순서에 따라 이어진 형태이며, 기본타입이므로 불변이다.
        - 각 값은 일반적으로 **[유니코드](https://www.notion.so/2-bc3773e018374b7a984c1beb833ebd28)** 문자다
        - 문자열의 길이(length): 그 문자열에 포함된 16비트 값의 개수, 인덱스는 0에서 시작 (첫 번째 16비트의 값: 0번 위치, 두 번째 16비트의 값: 1번 위치) / length 0: 빈 문자열
        - 자바스크립트는 **유니코드 문자셋의 UTF-16 인코딩을 사용하며, 부호 없는 16비트 값의 연속이다**
        - 가장 널리 사용되는 유니코드 문자의 코드 포인트는 16비트 이내이므로 문자열 요소 하나로 표현할 수 있다
            - **써로게이트 페어(surroagete pair)규칙:** 코드 포인트가 16비트를 넘는 유니코드 문자는 16비트 값 두 개를 연속으로 사용하여 인코드한다. → love는 길이는 2이지만, 유니코드 문자 1개이다.
                
                ```jsx
                   let euro = '€';
                   let love = '❤';
                   euro.length // 1;
                   love.length // 2; \ud83d\udc99
                ```
            
        - 자바스크립트의 문자열 메서드는 대부분 문자가 아니라 16비트 값 단위로 동작한다. 문자열 메서드는 써로게이트 페어를 특별 취급하지 않고, 따로 정규화하지 않고, 심지어 문자열이 정확한 UTF-16형식인지 검사하지도 않는다
        - 그러나 ES6에서 문자열은 이터러블(iterable)이고, 문자열에 `for/of` 루프나 .`..operator`를 사용하면 16비트 값이 아닌 실제 문자를 순회한다
        
        - **문자열 리터럴:** 작은따옴표(`’`), 큰따옴표(`”`), 백틱(```) 쌍으로 묶인 형식
            - 띄어쓰기: 최초 버전은 단 한 줄에만 쓸 수 있게 규정되었으나, ES5부터는 `\`, `\n`을 사용하여 뉴라인을 만들 수 있다.
                
                ```jsx
                   console.log('two\nlines');
                   // two
                   // lines
                
                   console.log('one\
                   long\
                   line');
                   // onelongline
                ```
                
                - `can’t` 에서 사용되는 `‘`(아포스트로피)와 작은따옴표는 동일하므로 `‘can’t’`을 콘솔에 표현하기 위해서는 역슬래시를 사용(`‘can\’t’`)하여 이스케이프 해야 한다.
                
        - **문자열 리터럴 안의 이스케이프 시퀀스**
            - 역슬래시(\): 역슬래시는 특별한 의미를 갖는다. 역슬래시는 그 다음 문자와 조합해서 일반적인 방법으로는 문자열에 표시할 수 없는 문자를 표현한다
            - 이스케이프 시퀀스: 역플래시를 써서 작은 따옴표로 감싸인 문자의 일반적인 해석 방법을 벗어난다(이스케이프한다)는 의미이다.
                - `\n`은 new line 문자를 표현하는 이스케이프 시퀀스이다
            
        - 문자열 다루기: 문자열을 비교할 때는 정확히 같은 16비트 값의 연속으로 이루어졌을 때만 일치한다.
            - 문자열 비교: 16비트 값을 비교하는 방식으로 이루어집니다.
            - 문자열 길이: 그 안에 포함된 16비트 값의 개수
        - 템플릿 리터럴(ES6): 임의의 자바스크립트 표현식을 넣을 수 있다.
            - 과정: 백틱으로 둘러싼 문자열 리터럴(ex. ``test${1+2}``)  → 안에 포함된 표현식 평가(ex.  ``test${3}``) -> 그 표현식의 값을 문자열로 변환 (ex.  ``test'3'``) -> 백틱 안에 있는 리터럴 문자와 결합한 값으로 결정(ex.  `test3`)
            - **태그된 템플릿 리터럴: 여는 백틱 바로 앞에 함수 이름(태그)이 있으면 템플릿 리터럴의 텍스트와 표현식 값이 함수에 전달된다. 그리고 이 태그된 템플릿 리터럴의 값이 함수의 반환 값이다.**
                - 언제 사용할까? **HTML이나 SQL을 텍스트에 붙이기 전에 이스케이프 하는 용도로 사용한다.**
                - ES6 내장 함수 `String.raw()`: 역슬래시 이스케이프를 처리하지 않고 백틱 안의 텍스트를 반환한다.
                    
                    ```jsx
                    `\n`.lnegth // 1: 이 문자열에는 뉴라인 문자 하나만 있다.
                    String.raw`\n`.length // 2: 역슬래시 문자와 n 
                    ```
                    
                    - 태그된 템플릿 리터럴의 태그 부분이 함수임에도 불구하고 괄호 없이 호출된 것을 볼 수 있다. → **이 함수는 문자열을 반환할 필요가 없으며, 새로운 리터럴 문법을 정의하는 것처럼 생성자로 사용할 수도 있다(14.5절 확인)**
                    
        - 패턴 매칭
            - **정규 표현식(RegExp)(11.3절 확인)**: 자바스크립트에는 문자열 내부의 패턴을 정의하고 매칭하는 데이터 타입
                - 숫자 및 문자열과 마찬가지로 리터럴 문법이 있으므로 기본적인 데이터 타입처럼 보이나, 자바스크립트의 기본적인 데이터 타입은 아니다.
                - 정규 표현식 리터럴은 슬래시 한 쌍 사이에 텍스트를 쓰는 형태다 (슬래시 뒤 글자 사용 → 패턴의 의미를 수정)
        
    - **불 값**
        - 참(true) 또는 거짓(false)을 표현
        - `false`로 동작하는 값들: `undefined`, `null`, `0`, `-0`, `NaN`, `“”` → falsy 값
        - `true`로 동작하는 값들: 빈객체와 빈배열을 포함한 다른 값 → truthy 값
        - 불 연산자
            - `&&` 연산자: `AND` 연산 → 두 피연산자가 모두 `true` 값일 때만 `true`로 평가
            - `||` 연산자: `OR` 연산 → 두 피연산자 중 하나 이상이 `true` 값일 때만 `true`로 평가
            - `!`연산자: `NOT` 연산 → 피연산자가 `false` ⇒ `true`, `true` ⇒ `false` 평가
        
    - **null과 undefined**
        - `null`: 값이 없음을 나타낼 때 사용하는 특별한 값
            - `typeof null`: object를 반환한다. null은 해당 타입의 유일한 멤버로, 객체뿐 아니라 숫자나 문자열에도 ‘값이 없다'는 의미로 사용할 수 있다.
            - **프로그램 레벨이고 정상적이거나 예측된 상황에서 값이 없는 것**
            - `null`이나 `undefined`를 쓰지 않으려고 해야하나 둘 중에 꼭 사용해야한다면 `null`을 사용하기
            
        - `undefined`: 초기화되지 않은 변수의 값
            - `undefined` 값으로 리턴되는 상황
                - 존재하지 않는 객체 프로퍼티나 배열 요소에 접근했을 때 반환되는 값
                - 리턴값이 없는 함수의 리턴값 (void function)
                - 전달되지 않은 인자의 값
            - **시스템 레벨이고 예측되지 않았거나 에러 비슷한 상황에서 값이 없는 것**
        
    - **심벌(Symbol) → 문자열이 아닌 프로퍼티 이름으로 ES6에서 추가**
        - 심벌을 이해하기 위해서는? JS 객체 타입에는 프로퍼티 순서가 없고, 각 프로퍼티에 name, value가 있다는 것을 이해하기
        - 리터럴 문법이 없다 → 심벌 값을 가져올 때는 `Symbol()` 호출
            - `Symbol()`: 절대 같은 값을 반환하지 않는다. 같은 인자로 호출하더라도 다른 값 반환
                - 즉, `Symbol()`을 호출해 심벌 값을 얻었다면 객체의 기존 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프로퍼티 이름으로 추가할 수 있다는 뜻
                - 심벌인 프로퍼티 이름을 사용하고 그 심벌을 공유하지 않는다면, 프로그램의 다른 모듈에서 실수로 우리가 만든 프로퍼티를 덮어 쓸 일이 없다는 뜻
                
        - 심벌(자바스크립트 언어를 확장하는 메커니즘)이 생기게 된 히스토리
            
            <aside>
            💡 ES6에서 for/of 루프와 이터러블 객체를 도입했을 때, 클래스가 자기 자신을 이터러블로 만들 수 있는 표준 메서드를 정의했어야 했다. 하지만 특정 문자열 이름을 이터리에터 메서드로 표준화하면 기존 코드가 깨지는 것을 피할 수 없었기에 심벌 이름을 도입한 것이다. (12장 참고)
            
            </aside>
            
        - 심벌 관련 함수
            - `toString()`:
            - `Symbol.for()`: 심벌을 확장시켜 다른 코드에서도 사용할 수 있도록 하는 것
                - 문자열 인자를 받고 그 문자열과 연관된 심벌 값을 리턴한다
                    - 문자열과 연관된 심벌 존재 X: 새 심벌을 생성해 리턴
                    - 문자열과 연관된 심벌 존재 O: 기존 심벌 리턴
                - `Symbol()`은 절대 같은 값을 반환하지 않지만, `Symbol.for()`는 같은 문자열로 호출했을 때 항상 같은 값 반환
            
            ```jsx
            let s = Symbol("sym_x");
            s.toString() // Symbol(sym_x)
            
            let a = Symbol.for("shared");
            let b = Symbol.for("shared");
            a === b; // true
            a.toString() // Symbol(shared)
            Symbol.keyFor(b) // shared
            ```
            
    - **전역 객체**
        - **자바스크립트 인터프리터를 시작할 때마다(또는 웹 브라우저가 새 페이지를 로드할 때마다) 다음과 같은 프로퍼티를 가진 새 전역 객체를 생성한다.**
        - 전역 객체 종류
            - `undefined`, `Infinity`, `NaN` 같은 전역 상수
            - `isNaN()`, `parseInt()`, `eval()` 같은 전역 함수
            - `Date()`, `RegExp()`, `String()`, `Object()`, `Array()` 같은 생성자 함수
            - `Math`와 `JSON` 같은 전역 객체
        - 전역 객체의 초기 프로퍼티는 예약어가 아니지만 예약어로 간주해야한다.
        
    - 불변인 기본 값과 가변인 객체 참조
        - immutable type (기본타입): 값으로 비교한다
            - `Number, Null, Undefined, String`
                - `String`: 문자의 배열이므로 특정 인덱스의 문자를 바꿀 수 있다고 생각할 수도 있으나, 자바스크립트는 이를 허용하지 않으며 몇몇 메서드가 수정된 문자열을 반환하는 것처럼 보이지만, 사실 새 문자열 값을 반환하는 것이다.
            
        - matable type (객체타입): 참조를 비교한다
            - `Object, Array`
            - 객체나 배열을 변수에 할당한다고 해서 객체의 사본이 새로 생기는 것이 아니다, 객체나 배열의 사본을 만들기 위해서는 반드시 객체 프로퍼티나 배열 요소를 “직접" 복사해야 한다.

3. **타입변환**
    - **명시적 변환:** 자바스크립트가 자동으로 타입을 변환하지만 때때로 직접 변환해야 할 때 사용 → `Boolean(), Number(), String()` 함수 사용
        - `Boolean(), Number(), String()` 함수는 모두 new와 함께 호출해서 생성자로 사용 가능. 이런 식으로 사용하면 기본 불, 숫자, 문자열 값과 똑같이 동작하는 ‘래퍼' 객체를 얻는다. 이런 래퍼 객체는 자바스크립트의 초창기에 잠시 사용되었지만, 지금은 이를 사용할 이유가 없다 (왜?)

    - **객체를 기본 값으로 변환하는 3가지 방법**
        - **문자열 선호**: 기본 값을 반환할 때 문자열로 변환할 수 있다면 문자열 값 우선
        - **순자 선호**: 기본 값을 반환할 때 숫자로 변환할 수 있다면 숫자 값 우선
        - **선호 없음**: 어떤 기본 타입을 선호하는지 정해 놓지 않았으며 클래스에서 변환 방법을 정의할 수 있음
            - Date를 제외한 모든 타입이 숫자 선호를 적용한다

    - 객체를 기본 값으로 변환
        - 객체를 불로 변환: 객체는 모두 true로 변환
        - 객체를 문자열로 변환: 문자열 선호 알고리즘을 이용
            - 기본 값으로 변환 → 문자열로 변환
        - 객체를 숫자로 변환
        - 특별한 케이스인 연산자 변환

4. **변수 선언과 할당**
    - let과 const
    - 변수와 상수 스코프
    - var를 사용한 변수 선언

5. **분해 할당**