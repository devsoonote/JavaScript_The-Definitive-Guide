# 3. 타입, 값, 변수

> 자바스크립트 완벽가이드를 읽고 작성한 개인 노트입니다. 조원들과 토론을 통해서 서로 배운 내용과 깨달은 내용에 대해서 논의한 부분 또한 함께 녹이려고 노력했습니다.
>
1. **타입이란?**
   - 프로그래밍 언어에서 표현하고 조작할 수 있는 값의 종류를 타입이라 부르며, 어떤 타입을 지원하는지가 프로그래밍 언어의 가장 기본적인 특징을 이룬다.

2. **자바스크립트 타입**
   - 자바스크립트 타입은 기본 타입과 객체 타입 둘로 나뉘는데, 자바스크립트 기본 타입에는 숫자, 문자열, 불(boolean), null, undefined, 심벌(Symbol) 타입이 있다.
   - 자바스크립트에서 숫자, 문자열, 불, 심벌, null, undefined 중 어느 것에도 속하지 않는 값은 모두 객체이다. (객체, 배열, Set[값의 집합], Map[키와 값의 연결], RegExp[텍스트 패턴], Date타입, Error타입...)

   - **숫자[Number]: 기본 타입**
      - 정수와 함께 실수를 대략적으로 표현
      - 자바스크립트는 IEEE 754 표준에서 정의하는 64비트 부동 소수점 형식을 사용해 숫자를 표현한다.
      - -2^53(-9,007,199,254,740,992) ~ 2^53(9,007,199,254,740,992) 범위의 정수를 정확히 표현할 수 있다. → 이보다 큰 정수 값을 사용하면 정확도가 떨어질 수 있다.
      - 배열 인덱싱이나 비트 연산자 등 일부 자바스크립트 연산은 32비트 정수를 사용한다. (왜달라?)
      - 숫자 리터럴: 자바스크립트 프로그램에 직접 기입한 숫자로 정수로 기입하면 정수 리터럴이고, 실수로 작성하면 부동 소수점 리터럴이다.
      - 숫자리터럴 안에 밑줄을 써서 리터럴을 읽기 쉽게 나눠 쓸 수 있다.

          ```jsx
          let billion = 1_000_000_000; // 천 단위 구분자로 사용
          let bytes = 0x89_AB_CD_EF; // 바이트 구분자로 사용
          let bites = 0b0001_1101_0111; // 4비트 구분자로 사용 
          let fraction = 0.123_456_789; // 소수점 아래 부분에도 사용 가능
          ```

         - 정수 리터럴
            - 10진 정수 리터럴 뿐만 아니라 16진수 값도 인식한다. → 16진수 리터럴은 0x 또는 0X로 시작하며 그 뒤에 숫자를 작성한다. `ex) 0xff ⇒ 255 (15*16 + 15), 0xBADCAFE ⇒ 195939070`
            - ES6 이후로는 2진수 및 8진수 정수도 표현할 수 있게 되었다. → 2진수는 0b(0B)을 앞에 붙이고, 8진수는 0o(0O)을 앞에 붙여 정수를 표현할 수 있다. `ex) 0b10101 ⇒ 21, 0o377 ⇒ 255`

         - 부동 소수점 리터럴
            - 부동 소수점 리터럴에는 소수점이 포함될 수 있다. 즉, 실수의 전통적 문법을 사용한다
            - 부동 소수점 리터럴은 지수 표기법으로도 표현할 수 있다 → 실수 다음에 e(E)를 쓰고, 그 뒤에 선택 사항인 플러스 또는 마이너스 기호, 마지막으로 지수를 나타내는 정수를 쓰는 형식 `[digits][.digits][(E|e)[(+|-)]digits]` `ex. 6.02e23⇒ 6.02 * 10^23`

      - 자바스크립트 산술 연산
         - 자바스크립트는 산술 연산자(`+`(더하기),`-`(빼기),`*`(곱하기),`/`(나누기),`%`(나머지),`**`(지수))를 통해 숫자를 조작한다
         - 산술 연산 과정에 0으로 나누거나 오버플로, 언더플로가 발생해도 에러를 일으키지 않는다.
            - 오버플로: 계산 결과가 자바스크립트가 표현할 수 있는 가장 큰 숫자보다 큰 경우  (`Infinity` or `-Infinity`를 반환한다)
            - 언더플로: 계산 결과가 자바스크립트가 표현할 수 있는 가장 작은 숫자보다도 0에 가까운 경우 (`0` or `음의 0`을 반환한다)

         - 무한한 값에 다른 숫자를 더하거나, 빼거나, 곱하거나, 나누더라도 결과는 여전히 무한한 값이다. → 부호는 바뀔 수 있다.
         - 자바스크립트를 0으로 나눠도 에러가 일어나지 않는다 → 무한대 또는 음의 무한대를 반환할 뿐이다
         - 자바스크립트를 0으로 나눌 때 NaN로 반환되는 상황
            1. 0을 0으로 나누는 경우: NaN(Not a Number)를 반환한다 → 0을 0으로 나누는 경우는 정의되어 있지 않음
            2. 무한대를 무한대로 나누는 경우
            3. 음수의 제곱근을 구하려는 경우
            4. 숫자로 변환할 수도 없는 피연산자에 산술 연산자를 적용하려 하는 경우

             - `NaN`(Not  a Number)
             - 자기 자신을 포함해 어떤 값과도 같지 않다 (`x = NaN; x === NaN; false;`) ⇒ `Number.isNaN(x)` 사용해서 판별가능
             - 전역 함수 `isNaN()`은 `Number.isNaN()`과 비슷하다
                 - 이 함수는 인자가 `NaN`이거나 숫자가 아니면서 숫자로 변환할 수도 없는 값일 때 `true`를 반환한다.

        - 이진 부동 소수점 숫자와 반올림 오류
            - 실수는 무한이 많지만, 자바스크립트의 부동 소수점 형식으로 정확히 표현할 수 있는 숫자는 유한하다. → 자바스크립트로 실수를 다룰 때 실제 숫자의 근삿값으로 표현될 때가 자주 있다.
            - **IEEE 754 부동 소수점 표현은 이진 표현이며 1/2, 1/8, 1/1024 같은 분수는 정확히 표현할 수 있으나 10진수인 1/10, 1/100 같은 숫자는 정확히 표현할 수 없다. 이진 부동 소수점은 0.1 같은 단순한 숫자를 정확히 표현하지 못한다**
            - Tip: 부동 소숫점 근사값 때문에 프로그램에 문제가 생긴다면 정수로 변환하는 것을 고려해보기. 예를 들어 돈을 계산할 때 0.1달러 대신 10센트로 계산하는 방식을 사용

        - **BigInt: ES2020에서 정의한 자바스크립트의 최신 기능 중 하나이다**
            - 지원 브라우저: 크롬, 파이어폭스, 엣지, 노드, 사파리(14버전~)
            - 값이 정수인 숫자 타입
            - 다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가된 타입이다
            - **타이밍 공격을 방지할 수 없으므로 암호화에는 사용할 수 없다**
                - 타이밍 공격이란?
                - 왜 BigInt는 타이밍 공격을 방지할 수 없을까?
            - `BigInit 리터럴`:  연속된 숫자 다음에 소문자 n을 붙인 형식, 기본적으로 10진수지만 0b, 0o, 0x를 앞에 붙여 이진, 8진, 16진수의 BigInt를 만들 수 있다
            - `BigInt()`: 자바스크립트 숫자, 문자열을 BigInt 타입으로 변환
            - 자바스크립트 숫자와 산술 연산 비슷 / 나눗셈을 할 때 나머지를 버린다는 점이 다르다
            - BigInt형 연산은 BigInt형 값을 리턴한다
            - BigInt형 값과 일반 숫자를 섞어서 사용 불가능 (비교 연산자는 가능)
                - 왜 섞어서 사용이 불가능할까?
                    
                    > 💡 A와 B, 숫자 타입이 있다고 정의하였을 때, A 숫자 타입이 B 숫자 타입보다 더 광범위하다면, 두 가지의 타입이 섞였을 때, A 숫자 타입의 값을 반환하도록 정의한다면 섞어서 사용이 가능하다.
                    > 그러나 BigInt 타입은 단지 정수만 표현할 수 있고, 자바스크립트 숫자는 실수까지 표현할 수 있기 때문에 바라보는 측면에 따라 광범위한 정의가 달라질 수 있다. 그렇기 때문에 섞어서 사용이 불가능하다.
                
                - 섞어서 사용해야하는 상황이라면, `BigInt()` or `Number()`를 사용해 명시적으로 형 변형하기
                 ```jsx
                    let bigint = 1n;
                    let number = 2;
                    
                    // 숫자를 bigInt로 
                    alert(bigint + BigInt(number)); // 3
                    
                    // bigint를 숫자로 
                    alert(Number(bigint) + number); // 3
                 ```
   - 텍스트
     - ㅇㅇ
   - 불 값
   - null과 undefined
   - 심벌
   - 전역 객체
   - 불변인 기본 값과 가변인 객체 참조
   - 객체타입 - Reference Type(mutable)

3. **타입변환**
4. **변수 선언과 할당**
   - let과 const
   - 변수와 상수 스코프
   - var를 사용한 변수 선언